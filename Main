import tkinter as tk
import tkinter.scrolledtext
from tkinter import ttk, filedialog
import time
import subprocess  # open character map
# from spellchecker import SpellChecker
import re
import pyqrcode
from translate import Translator

import Categories

"""
==VERSION NOTES==
1.0 - Creation
1.1 - Status bar font change
    - Char count excludes spaces
1.5 - Insert tables BETA (misaligned after 7 columns) Temporarily removed
1.6 - Some tk. > ttk.
2.0 - Code reformatting
2.1 - Spellcheck
2.2 - Highlight and pizzazz tagging (need to allow saving these settings)
2.3 - Translation
2.4 - Case changing
    - No Distractions mode
Planned - Thesaurus (import thesaurus), dictionary (import pydictionary), drag-and-drop files, images
"""

NAME = "DNBG"
VERSION = 2.4

class ScrollableFrame:
    def __init__(self,root,width=80,item_width=10,height=None,anchor="w",orient="Y",rootX=None,list=None,list_type=None,command=None,bd=1,bg="SystemButtonFace",relief="sunken",item_relief="flat"):
        self.root = root
        self.width = width
        self.item_width = item_width
        self.height = height
        self.anchor = anchor
        self.orient = orient
        self.rootX = rootX
        self.list = list
        self.list_type = list_type
        self.command = command
        self.relief = relief
        self.item_relief = item_relief
        self.bd = bd
        self.bg = bg

        self.container = tk.Frame(
            self.root, bd=self.bd, relief=self.relief
        )
        self.canvas = tk.Canvas(
            self.container,width=self.width,height=self.height,bg=self.bg
        )

        if self.orient == 'Y':
            self.scrollbar = ttk.Scrollbar(
                self.container, orient=tk.VERTICAL, command=self.canvas.yview
            )
        elif self.orient == 'x':
            self.scrollbar = ttk.Scrollbar(
                self.rootX, orient=tk.HORIZONTAL, command=self.canvas.xview
            )

        self.scrollable_frame = ttk.Frame(self.canvas) # put items here
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        self.canvas.create_window(
            (0,0),
            window = self.scrollable_frame,
            anchor = tk.NW
        )

        if self.orient == 'Y':
            self.scrollbar.pack(side=tk.RIGHT,fill=tk.Y,expand=True)
            self.canvas.configure(yscrollcommand=self.scrollbar.set)

        elif self.orient == 'X':
            self.scrollbar.pack(side=tk.RIGHT,fill=tk.X,expand=True)
            self.canvas.configure(xscrollcommand=self.scrollbar.set)

        self.canvas.pack(side=tk.LEFT,fill=tk.BOTH,expand=True)


        if not self.list:
            pass
        else:
            for i in self.list:
                if self.list_type is "label" or not self.list:
                    tk.Label(
                        self.scrollable_frame,
                        text = i,
                        width = self.item_width,
                        relief = self.item_relief
                    ).pack(fill=tk.X)
                elif self.list_type is "button":
                    tk.Button(
                        self.scrollable_frame,
                        text = i,
                        width = self.item_width,
                        relief = self.item_relief,
                        anchor = self.anchor,
                        command = self.command
                    ).pack(fill=tk.X)


class WordProcessor:
    def __init__(self, root=tk.Tk(), font="times"):
        self.root = root
        #self.icon = r"C:\Users\xain1\AppData\Roaming\JetBrains\PyCharmCE2021.2\scratches\DNBG\DNBGicon.ico"
        #self.root.iconbitmap(self.icon)
        self.root.title(f"{NAME} {VERSION}")
        self.font = font
        self.fullscreen = False
        self.to_change = ""
        self.color_tags = []
        self.font_tags = []

        def want_to_save():  # wts
            def win_close():
                wts.destroy()
                self.root.destroy()

            def save_as_2():
                wts.destroy()
                save_as()

            wts = tk.Tk()  # want-to-save popup
            wts.resizable(False, False)
            #wts.iconbitmap(self.icon)
            wts.update()
            wts.geometry(
                f"160x48+"
                f"{(root.winfo_x() + root.winfo_width()//2) - wts.winfo_width()//2}+"
                f"{(root.winfo_y() + root.winfo_height()//2)}"
            )
            message = ttk.Label(wts, text="Do you want to save?")
            message.grid(row=0, column=0, columnspan=2, padx=2)
            YES = ttk.Button(wts, text="Yes", command=save_as_2)
            YES.grid(row=1, column=0, sticky=tk.EW, padx=2)
            NO = ttk.Button(wts, text="No", command=win_close)
            NO.grid(row=1, column=1, sticky=tk.EW, padx=2)

        self.root.protocol("WM_DELETE_WINDOW", want_to_save)  # ask to save on X-click

        # text area
        textFrame = tk.LabelFrame(self.root, width=0, height=0)
        textFrame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        paper = tk.scrolledtext.ScrolledText(
            textFrame,
            height=31,
            font=self.font,
            undo=True,
            autoseparators=True,
            wrap=tk.WORD,
        )  # main typing area
        paper.pack(fill=tk.BOTH, expand=True)

        menubar = tk.Menu(self.root)
        self.root["menu"] = menubar

        def save_as():
            to_save = filedialog.asksaveasfile(
                mode="w",
                initialfile="Untitled.txt",
                defaultextension=".txt",
                filetypes=[("All Files", "*.*"), ("Text Documents", "*.txt")],
            )
            to_save.write(str(FONT_name.get()))
            to_save.write("\n")
            to_save.write(FONT_size.get())
            to_save.write("\n")
            to_save.write(FONT_xtra.get())
            to_save.write("\n")
            to_save.write(FONT_color.get())
            to_save.write("\n")
            to_save.write(paper.get(0.0, "end-1c"))
            to_save.close()

        def load():
            to_load = filedialog.askopenfile(
                mode="r",
                defaultextension=".txt",
                filetypes=[("All Files", "*.*"), ("Text Documents", "*.txt")],
            ).read()
            paper.replace(0.0, "end-1c", to_load)
            try:
                paper.config(
                    font=(  # set font
                        paper.get(1.0, 1.999),
                        paper.get(2.0, 2.999),
                        paper.get(3.0, 3.999),
                    ),
                    fg=paper.get(4.0, 4.999),
                )
            except:
                paper.config(font="TkDefaultFont")
            paper.delete(0.0, 5.0)  # remove font settings from main text

        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu, compound=tk.LEFT)
        file_menu.add_command(label="Save As (Ctrl+S)", command=save_as)
        file_menu.add_command(label="Load    (Ctrl+O)", command=load)

        def spellcheck():
            width = 300
            height = 100

            spellcheck_win = tk.Tk()
            spellcheck_win.resizable(False, False)
            spellcheck_win.title("Spellcheck")
            #spellcheck_win.iconbitmap(self.icon)
            spellcheck_win.update()
            spellcheck_win.geometry(
                f"+{(root.winfo_x() + root.winfo_width()//2) - spellcheck_win.winfo_width()}+"
                f"{(root.winfo_y() + root.winfo_height()//2) - spellcheck_win.winfo_height()//2}"
            )

            WRONG_words = ScrollableFrame(
                spellcheck_win,
                height=height,
                width=width,
                list_type="button",
                bg="white",
            )  # where misspelled words appear
            WRONG_words.container.pack(side=tk.TOP, pady=5, fill=tk.BOTH, expand=True)

            CORRECT_words = ScrollableFrame(
                spellcheck_win,
                height=height,
                width=width,
                list_type="button",
                bg="white",
            )  # where corrections appear
            CORRECT_words.container.pack(
                side=tk.TOP, pady=(0, 5), fill=tk.BOTH, expand=True
            )

            spell = SpellChecker()
            WORDS = paper.get(1.0, "end-1c").split()
            misspelled = spell.unknown([i for i in WORDS])

            def correct(x):
                text = str(paper.get(1.0, "end-1c"))
                find = str(self.to_change)
                repl = str(x)
                n = text.replace(find, repl)
                paper.delete(1.0, "end-1c")
                paper.insert(1.0, n)
                self.to_change = x

            def get_corrections(x):
                self.to_change = x
                for i in CORRECT_words.scrollable_frame.winfo_children():
                    i.destroy()
                if len(spell.candidates(x)) < 2:
                    item = tk.Label(
                        CORRECT_words.scrollable_frame,
                        text="No replacements found",
                        relief=tk.FLAT,
                        width=100,
                        anchor="w",
                        bg="white",
                        activebackground="white",
                    )
                    item.pack(side=tk.TOP)
                else:
                    for i in spell.candidates(x):
                        item = tk.Button(
                            CORRECT_words.scrollable_frame,
                            text=i,
                            relief=tk.FLAT,
                            width=100,
                            anchor="w",
                            bg="white",
                            activebackground="white",
                            command=lambda x=i: correct(x),
                        )
                        item.pack(side=tk.TOP)

            for i in misspelled:
                item = tk.Button(
                    WRONG_words.scrollable_frame,
                    text=i,
                    relief=tk.FLAT,
                    width=100,
                    anchor="w",
                    bg="white",
                    activebackground="white",
                    command=lambda x=i: get_corrections(x),
                )
                item.pack(side=tk.TOP)

        def translate_():
            translate_win = tk.Tk()
            translate_win.resizable(False, False)
            #translate_win.icon = r"C:\Users\xain1\AppData\Roaming\JetBrains\PyCharmCE2021.2\scratches\DNBG\DNBGicon.ico"
            translate_win.iconbitmap(self.icon)

            def translate_text():
                output.delete(1.0,"end-1c")
                translator = Translator(to_lang=language_select.get())
                translation = translator.translate(input.get(1.0,"end-1c"))
                output.insert("end-1c",translation)

            text_space = tk.Frame(translate_win)
            text_space.pack(side=tk.LEFT,expand=True)

            input = tk.Text(text_space,height=4,width=40)
            input.pack(side=tk.TOP)

            output = tk.Text(text_space,height=5,width=40)
            output.pack(side=tk.TOP)

            btn_space = tk.Frame(translate_win)
            btn_space.pack(side=tk.LEFT,expand=True,fill=tk.BOTH)

            translate_btn = ttk.Button(
                btn_space,text='Translate',command=translate_text
                )
            translate_btn.pack(side=tk.TOP,pady=5,padx=5,anchor=tk.W,fill=tk.X)

            language_select = ttk.Combobox(
                btn_space,
                values=["Chinese", "English", "French", "German", "Spanish"],
                state="readonly",
            )
            language_select.pack(side=tk.TOP,pady=5,padx=5,anchor=tk.W,fill=tk.X)
            language_select.set("English")

            translate_win.update()
            translate_win.geometry(
                f"450x135+"
                f"{(root.winfo_x() + root.winfo_width()//2) - translate_win.winfo_width()//2}+"
                f"{(root.winfo_y() + root.winfo_height() // 2 - translate_win.winfo_height() // 4)}"
            )

        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=edit_menu, compound=tk.LEFT)
        edit_menu.add_command(label="Spellcheck", command=spellcheck)
        edit_menu.add_command(label="Translate", command=translate_)

        def light_mode():
            paper.config(bg="white", fg="black", font=self.font)
            attributes_frame.pack(side=tk.RIGHT, fill=tk.BOTH, padx=5)

        def dark_mode():
            paper.config(bg="black", fg="white", font=self.font)
            attributes_frame.pack(side=tk.RIGHT, fill=tk.BOTH, padx=5)

        def retro_mode():
            paper.config(bg="gray10", fg="light green", font=["Terminal", 20, "normal"])
            attributes_frame.pack(side=tk.RIGHT, fill=tk.BOTH, padx=5)

        def no_dis_mode():
            attributes_frame.pack_forget()

        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu, compound=tk.LEFT)

        mode_menu = tk.Menu(view_menu, tearoff=0)
        view_menu.add_cascade(label="Mode", menu=mode_menu, compound=tk.LEFT)
        mode_menu.add_command(label="Light Mode", command=light_mode, compound=tk.LEFT)
        mode_menu.add_command(label="Dark Mode", command=dark_mode, compound=tk.LEFT)
        mode_menu.add_command(label="Retro Mode", command=retro_mode, compound=tk.LEFT)
        mode_menu.add_command(label="No Distractions Mode", command=no_dis_mode, compound=tk.LEFT)

        format_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Format", menu=format_menu, compound=tk.LEFT)

        def default_formatting():  # clear all tags
            for i in paper.tag_names():
                paper.tag_delete(i)

        format_menu.add_command(label="Default Format", command=default_formatting)
        format_menu.add_separator()

        def double_space(spacing):
            paper.tag_add("whole", "2.0", "end-1c")
            paper.tag_configure("whole", spacing1=spacing)

        spacing_menu = tk.Menu(format_menu, tearoff=0)
        format_menu.add_cascade(
            label="Line Spacing", menu=spacing_menu, compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="None", command=lambda: double_space(0), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="0.5", command=lambda: double_space(5), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="1.0", command=lambda: double_space(10), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="1.25", command=lambda: double_space(12.5), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="1.5", command=lambda: double_space(15), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="2.0", command=lambda: double_space(20), compound=tk.LEFT
        )
        spacing_menu.add_command(
            label="2.5", command=lambda: double_space(25), compound=tk.LEFT
        )

        def highlight(color, color2):  # BETA
            paper.tag_add(f"{color}{color2}", tk.SEL_FIRST, tk.SEL_LAST)
            paper.tag_configure(f"{color}{color2}", background=color, foreground=color2)
            if f"{color}{color2}" not in self.color_tags:
                self.color_tags.append(f"{color}{color2}")

        def remove_all_highlights():  # doesn't include line spacing or font settings
            for i in self.color_tags:
                paper.tag_delete(i)

        def remove_selected_highlight():  # currently applies to all highlights of same color.  How to change?
            for tag in paper.tag_names():
                SPAN = re.findall(r"\d*\.\d*", str(paper.tag_ranges(tag)))
                if len(SPAN) > 0:
                    if SPAN[0] <= paper.index(tk.INSERT) <= SPAN[1]:
                        paper.tag_delete(tag)

        highlight_tagging_menu = tk.Menu(format_menu, tearoff=0)
        format_menu.add_cascade(
            label="Highlight", menu=highlight_tagging_menu, compound=tk.LEFT
        )
        highlight_tagging_menu.add_command(
            label="Default",
            command=lambda: highlight("white", "black"),
            compound=tk.LEFT,
        )
        highlight_tagging_menu.add_command(
            label="Inverted",
            command=lambda: highlight("black", "white"),
            compound=tk.LEFT,
        )
        highlight_tagging_menu.add_command(
            label="Yellow",
            command=lambda: highlight("yellow", "black"),
            compound=tk.LEFT,
        )
        highlight_tagging_menu.add_separator()
        highlight_tagging_menu.add_command(
            label="Remove all",
            command=lambda: remove_all_highlights(),
            compound=tk.LEFT,
        )
        highlight_tagging_menu.add_command(
            label="Remove selected",
            command=lambda: remove_selected_highlight(),
            compound=tk.LEFT,
        )

        def pizzazz_set_tag(tag):
            paper.tag_add(tag, tk.SEL_FIRST, tk.SEL_LAST)
            paper.tag_configure(tag, font=[FONT_name.get(), FONT_size.get(), tag])
            if tag not in self.font_tags:
                self.font_tags.append(tag)

        def remove_all_pizzazz():  # doesn't include line spacing or highlight settings
            for i in self.font_tags:
                paper.tag_delete(i)

        def remove_selected_pizzazz():  # currently applies to all highlights of same color.  How to change?
            for tag in paper.tag_names():
                SPAN = re.findall(r"\d*\.\d*", str(paper.tag_ranges(tag)))
                if len(SPAN) > 0:
                    if SPAN[0] <= paper.index(tk.INSERT) <= SPAN[1]:
                        paper.tag_delete(tag)

        pizzazz_tagging_menu = tk.Menu(format_menu, tearoff=0)
        format_menu.add_cascade(
            label="Pizzazz", menu=pizzazz_tagging_menu, compound=tk.LEFT
        )
        pizzazz_tagging_menu.add_command(
            label="Default", command=lambda: pizzazz_set_tag("normal"), compound=tk.LEFT
        )
        pizzazz_tagging_menu.add_command(
            label="Bold", command=lambda: pizzazz_set_tag("bold"), compound=tk.LEFT
        )
        pizzazz_tagging_menu.add_command(
            label="Italics", command=lambda: pizzazz_set_tag("italic"), compound=tk.LEFT
        )
        pizzazz_tagging_menu.add_command(
            label="Underline",
            command=lambda: pizzazz_set_tag("underline"),
            compound=tk.LEFT,
        )

        pizzazz_tagging_menu.add_separator()
        pizzazz_tagging_menu.add_command(
            label="Remove all", command=lambda: remove_all_pizzazz(), compound=tk.LEFT
        )
        pizzazz_tagging_menu.add_command(
            label="Remove selected",
            command=lambda: remove_selected_pizzazz(),
            compound=tk.LEFT,
        )

        def change_case(case):
            n = paper.get(1.0,"end-1c")
            if case == "upper":
                n = n.upper()
            elif case == "lower":
                n = n.lower()
            elif case == "title":
                n = n.title()
            paper.delete(1.0,"end-1c")
            paper.insert("end-1c",n)

        upper_lower_menu = tk.Menu(format_menu,tearoff=0)
        format_menu.add_cascade(
            label="Change Case",menu=upper_lower_menu,compound=tk.LEFT
        )
        upper_lower_menu.add_command(
            label="Upper",command=lambda: change_case("upper")
        )
        upper_lower_menu.add_command(
            label="Lower",command=lambda: change_case("lower")
        )
        upper_lower_menu.add_command(
            label="First Letter",command=lambda: change_case("title")
        )

        def get_time():
            paper.insert(tk.INSERT, time.strftime("%H:%M:%S"))

        def get_date():
            paper.insert(tk.INSERT, time.strftime("%d-%m-%y"))

        def time_date():
            paper.insert(
                tk.INSERT, (time.strftime("%H:%M:%S"), time.strftime("%d-%m-%y"))
            )

        def char_map():
            subprocess.call("C:\WINDOWS\system32\charmap.exe")

        insert_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Insert", menu=insert_menu, compound=tk.LEFT)
        insert_menu.add_command(label="Time", command=get_time)
        insert_menu.add_command(label="Date", command=get_date)
        insert_menu.add_command(label="Time and Date", command=time_date)
        insert_menu.add_separator()
        insert_menu.add_command(label="Special Character", command=char_map)

        def about():
            about_win = tk.Tk()  # about popup
            about_win.resizable(False, False)
            about_win.iconbitmap(self.icon)
            about_win.update()
            about_win.geometry(
                f"450x135+"
                f"{(root.winfo_x() + root.winfo_width() // 2) - about_win.winfo_width()}+"
                f"{(root.winfo_y() + root.winfo_height() // 2 - about_win.winfo_height() // 4)}"
            )
            about_note = ttk.Label(
                about_win,
                justify="left",
                text=f"""Thank you for using {NAME} - free note taker. The name is a play on the
        Mandarin 电笔记 (dian4 bi3 ji4), which means 'electric note' and is pronounced
        roughly the same. You are using version {VERSION} of the program.

        New versions will be released occasionally with added features, improvements,
        and adjustments.\n\nEnjoy!""",
            )
            about_note.pack(fill=tk.BOTH, padx=5, pady=1)

        def text_to_qr():
            to_convert = paper.get(0.0, "end-1c")
            to_scan = pyqrcode.create(to_convert, encoding="utf-8")
            to_scan.png("My QRcode.png", scale=6)
            from PIL import Image

            img = Image.open("My QRcode.png")
            img.show()

        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu, compound=tk.LEFT)
        help_menu.add_command(label="About", command=about)
        help_menu.add_command(label="QRcode", command=text_to_qr)

        # right side
        attributes_frame = tk.Frame(self.root)
        attributes_frame.pack(side=tk.RIGHT, fill=tk.BOTH, padx=5)

        def replace():
            text = str(paper.get(1.0, "end-1c"))
            find = str(FIND.get())
            repl = str(REPLACE.get())
            n = text.replace(find, repl)
            paper.delete(1.0, "end-1c")
            paper.insert(1.0, n)

        replace_frame = tk.Frame(attributes_frame)
        replace_frame.pack(side=tk.TOP, fill=tk.BOTH)

        FIND_lab = tk.Label(replace_frame, text="Find")
        FIND_lab.grid(row=0, column=0, sticky=tk.W)
        FIND = ttk.Entry(replace_frame)
        FIND.grid(row=1, column=0, sticky=tk.EW)
        REPLACE_lab = tk.Label(replace_frame, text="Replace")
        REPLACE_lab.grid(row=2, column=0, sticky=tk.W)
        REPLACE = ttk.Entry(replace_frame)
        REPLACE.grid(row=3, column=0, sticky=tk.EW)
        REPLACE_btn = ttk.Button(replace_frame, text="Replace", command=replace)
        REPLACE_btn.grid(row=4, column=0, sticky=tk.EW, pady=(5, 0))

        def font_set():
            if paper.index(tk.SEL_FIRST) == paper.index(tk.SEL_LAST):
                paper.config(
                    font=(
                        str(FONT_name.get()),
                        int(FONT_size.get()),
                        str(FONT_xtra.get()),
                    ),
                    fg=FONT_color.get(),
                )  # if nothing is selected, change all
            else:
                paper.tag_add(f"dn", tk.SEL_FIRST, tk.SEL_LAST)
                paper.tag_configure(
                    f"dn",
                    font=(
                        str(FONT_name.get()),
                        int(FONT_size.get()),
                        str(FONT_xtra.get()),
                    ),
                    fg=FONT_color.get(),
                )  # change selected

        font_frame = tk.Frame(attributes_frame)
        font_frame.pack(side=tk.TOP, fill=tk.BOTH)

        font_name_frame = tk.Frame(font_frame)
        font_name_frame.pack(side=tk.TOP, fill=tk.BOTH)

        FONT_name_lbl = tk.Label(font_frame, text="Font Name")
        FONT_name_lbl.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_name = ttk.Combobox(
            font_frame,
            values=Categories.font_names,
            state="readonly",
            width=17,
        )
        FONT_name.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_name.current(int(43))

        font_size_frame = tk.Frame(font_frame)
        font_size_frame.pack(side=tk.TOP, fill=tk.BOTH)

        FONT_size_lbl = tk.Label(font_frame, text="Font Size")
        FONT_size_lbl.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_size = ttk.Combobox(
            font_frame,
            values=Categories.font_sizes,
            state="readonly",
            width=17,
        )
        FONT_size.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_size.current(3)

        font_color_frame = tk.Frame(font_frame)
        font_color_frame.pack(side=tk.TOP, fill=tk.BOTH)

        FONT_color_lbl = tk.Label(font_frame, text="Font Color")
        FONT_color_lbl.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_color = ttk.Combobox(
            font_frame,
            values=Categories.font_colors,
            state="readonly",
            width=17,
        )
        FONT_color.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_color.current(0)

        font_xtra_frame = tk.Frame(font_frame)
        font_xtra_frame.pack(side=tk.TOP, fill=tk.BOTH)

        FONT_xtra_lbl = tk.Label(font_frame, text="Pizzazz")
        FONT_xtra_lbl.pack(side=tk.TOP, fill=tk.BOTH)
        FONT_xtra = ttk.Combobox(
            font_frame,
            values=Categories.font_other,
            state="readonly",
            width=17,
        )
        FONT_xtra.pack(side=tk.TOP, fill=tk.BOTH)

        FONT_btn = ttk.Button(font_frame, text="Set Font", command=font_set)
        FONT_btn.pack(side=tk.TOP, fill=tk.BOTH, pady=(5, 0))

        def align_left():
            paper.tag_configure("lefttag", justify="left")
            paper.tag_delete("centertag", "righttag")
            paper.tag_add("lefttag", 1.0, "end")

        def align_center():
            paper.tag_configure("centertag", justify="center")
            paper.tag_delete("lefttag", "righttag")
            paper.tag_add("centertag", 1.0, "end")

        def align_right():
            paper.tag_configure("righttag", justify="right")
            paper.tag_delete("lefttag", "centertag")
            paper.tag_add("righttag", 1.0, "end")

        align_frame = tk.Frame(attributes_frame)
        align_frame.pack(side=tk.TOP, fill=tk.BOTH, padx=(17, 0), pady=(5, 0))

        alignL = tk.Button(align_frame, text="", font=15, command=align_left)
        alignL.pack(side=tk.LEFT, fill=tk.BOTH)

        alignC = tk.Button(align_frame, text="", font=15, command=align_center)
        alignC.pack(side=tk.LEFT, fill=tk.BOTH)

        alignR = tk.Button(align_frame, text="", font=15, command=align_right)
        alignR.pack(side=tk.LEFT, fill=tk.BOTH)

        def status_bar_update():
            x = paper.get(0.0, "end-1c")
            words = len(x.split())
            chars = len([i for i in paper.get(0.0, "end-1c") if i not in (" ", "\n")])
            lines = int(float(paper.index("end")) - 1)
            pages = int((float(paper.index("end")) // 28)) + 1
            status.config(
                text=f"Chars: {chars}\nWords: {words}\nLines: {lines}\nPages: {pages}"
            )
            status.after(200, status_bar_update)

        status_frame = tk.Frame(attributes_frame, bg="lightgray", bd=1)
        status_frame.pack(side=tk.BOTTOM, fill=tk.BOTH, pady=(0, 5))

        status = tk.Label(
            status_frame,anchor="w",
            font=("times", 10, "normal"),
            text="Words:0\nChars:0\nLines:0\nPages:0",
        )
        status.pack(side=tk.TOP, fill=tk.BOTH)
        status_bar_update()

        self.root.bind("<Control-s>", save_as)
        self.root.bind("<Control-o>", load)

        self.root.mainloop()

WordProcessor()
